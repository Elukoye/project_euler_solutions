num = 73167176531330624919225119674426574742355349194934969
83520312774506326239578318016984801869478851843858615607891
12949495459501737958331952853208805511125406987471585238630
50715693290963295227443043557668966489504452445231617318564
03098711121722383113622298934233803081353362766142828064444
86645238749303589072962904915604407723907138105158593079608
66701724271218839987979087922749219016997208880937766572733
30010533678812202354218097512545405947522435258490771167055
60136048395864467063244157221553975369781797784617406495514
92908625693219784686224828397224137565705605749026140797296
86524145351004748216637048440319989000889524345065854122758
86668811642717147992444292823086346567481391912316282458617
86645835912456652947654568284891288314260769004224219022671
05562632111110937054421750694165896040807198403850962455444
36298123098787992724428490918884580156166097919133875499200
52406368991256071760605886116467109405077541002256983155200
05593572972571636269561882670428252483600823257530420752963
450

digits = 13

string = num.to_s

pos1 = 0
products = []

while pos1 < string.length - (digits - 1)

  number = string[pos1..pos1 + (digits - 1)].chars
  number.each_index {|i| number[i] = number[i].to_i}
  
  product = 1
  
  number.each {|i| product *= i}
  products << product

  pos1 += 1
  
end

location = products.index(products.max)
target = string[location..location + (digits - 1)]


answer = "The #{digits} adjacent digits in the 1000-digit number that have the greatest product are '#{target}'. They can be found between digits #{location} and #{location + (digits - 1)}. Their product is #{products.max}."
